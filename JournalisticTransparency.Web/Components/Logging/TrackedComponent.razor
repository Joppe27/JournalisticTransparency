@using System.Collections.ObjectModel
@using System.Collections.Specialized
@using ObservableCollections
@using System.Diagnostics
@inherits ComponentBase
@implements ITracked
@typeparam T where T : notnull, new()
@inject Stopwatch SessionTimer

<DynamicComponent @ref="@_dynamicComponent" Type="@_dynamicType" Parameters="@Attributes"/>

@code {
    [Parameter] public Dictionary<string, object>? Attributes { get; set; }
    [CascadingParameter] public EventCallback<ITracked> OnTrackedElementCreated { get; set; }
    [CascadingParameter] public EventCallback<ITracked> OnInteractionsChanged { get; set; }
    
    [Parameter] [EditorRequired] public required string Name { get; init; }
    [Parameter] [EditorRequired] public required IComponent Owner { get; init; }

    private DynamicComponent _dynamicComponent = null!;
    public object Object { get; private set; } = null!;
    private readonly Type _dynamicType = typeof(T);

    public TrackedStatus Status => DetermineStatus();
    public ObservableCollection<TrackedInteraction> Interactions { get; } = new();

    private bool _initialized;

    protected override void OnParametersSet()
    {
        base.OnParametersSet();

        if (!_initialized)
        {
            Interactions.CollectionChanged += (_, _) => OnInteractionsChanged.InvokeAsync(this);
            _initialized = true;
        }
    }

    protected override void OnAfterRender(bool firstRender)
    {
        base.OnAfterRender(firstRender);

        if (!firstRender)
            return;
        
        Object = _dynamicComponent.Instance ?? throw new NullReferenceException();
        OnTrackedElementCreated.InvokeAsync(this);
        
        if (Object is Modal)
        {
            AddCallbackToChild(nameof(Modal.Opened), new EventCallbackWrapper(EventCallback.Factory.Create(this, () => TrackInteraction(Interaction.Opened))));
            AddCallbackToChild(nameof(Modal.Closed), new EventCallbackWrapper(EventCallback.Factory.Create(this, () => TrackInteraction(Interaction.Closed))));
            StateHasChanged();
        }

        if (Object is AccordionToggle toggle)
        {
            AddCallbackToChild(nameof(AccordionToggle.Clicked), new EventCallbackWrapper<MouseEventArgs>(EventCallback.Factory.Create(this, (MouseEventArgs _) =>
            {
                TrackInteraction(!toggle.AccordionItemVisible ? Interaction.Opened : Interaction.Closed);
            })));
            StateHasChanged();
        }

        if (Object is Anchor)
        {
            AddCallbackToChild(nameof(Anchor.Clicked), new EventCallbackWrapper<MouseEventArgs>(EventCallback.Factory.Create(this, (MouseEventArgs _) => TrackInteraction(Interaction.Clicked))));
            StateHasChanged();
        }
    }

    private async Task InvokeNestedCallback(List<IEventCallback> callbacks)
    {
        foreach (IEventCallback callback in callbacks)
        {
            await callback.InvokeAsync();
        }
    }

    private void TrackInteraction(Interaction interaction) => Interactions.Add(new TrackedInteraction(interaction, SessionTimer.Elapsed));

    private void AddCallbackToChild(string eventName, IEventCallback callback)
    {
        Attributes ??= new();
        
        Attributes.TryGetValue(eventName, out var value);

        if (value is null)
        {
            Attributes[eventName] = callback.Object;
            return;
        }

        if (value is { } parentCallback)
        {
            // GARBAGE CODE ALERT!
            if (parentCallback is EventCallback parentEventCallback)
            {
                Attributes[eventName] = EventCallback.Factory.Create(this, () => InvokeNestedCallback([callback, new EventCallbackWrapper(parentEventCallback)]));
                return;
            }

            if (parentCallback is EventCallback<MouseEventArgs> parentMouseCallback)
            {
                Attributes[eventName] = EventCallback.Factory.Create<MouseEventArgs>(this, () => InvokeNestedCallback([callback, new EventCallbackWrapper<MouseEventArgs>(parentMouseCallback)]));
                return;
            }
        }
        
        throw new NotSupportedException();
    }

    private TrackedStatus DetermineStatus()
    {
        switch (Interactions.LastOrDefault()?.Interaction)
        {
            case Interaction.Opened:
                return TrackedStatus.Active;
            case Interaction.Closed:
                return TrackedStatus.Paused;
            case Interaction.Clicked:
                return TrackedStatus.Incremented;
            default:
                return TrackedStatus.Paused;
        }
    }
}